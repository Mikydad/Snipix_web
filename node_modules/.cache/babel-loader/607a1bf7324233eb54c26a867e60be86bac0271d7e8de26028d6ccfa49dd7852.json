{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { apiService } from '../../services/apiService';\nconst initialState = {\n  words: [],\n  isTranscribing: false,\n  error: null,\n  selectedWords: []\n};\n\n// Async thunks\nexport const transcribeAudio = createAsyncThunk('transcript/transcribeAudio', async (projectId, {\n  rejectWithValue\n}) => {\n  try {\n    const formData = new FormData();\n    formData.append('project_id', projectId);\n    const response = await apiService.post(`/media/transcribe`, formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    return rejectWithValue(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Transcription failed');\n  }\n});\nexport const removeFillers = createAsyncThunk('transcript/removeFillers', async ({\n  projectId,\n  selectedWords\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await apiService.post(`/media/remove-fillers`, {\n      projectId,\n      selectedWords\n    });\n    return response.data;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    return rejectWithValue(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Filler removal failed');\n  }\n});\nexport const removeAutoDetectedFillers = createAsyncThunk('transcript/removeAutoDetectedFillers', async (projectId, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await apiService.post(`/remove-fillers`, {\n      projectId,\n      autoDetect: true\n    });\n    return response.data;\n  } catch (error) {\n    var _error$response3, _error$response3$data;\n    return rejectWithValue(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || 'Auto filler removal failed');\n  }\n});\nconst transcriptSlice = createSlice({\n  name: 'transcript',\n  initialState,\n  reducers: {\n    setWords: (state, action) => {\n      state.words = action.payload;\n    },\n    toggleWordSelection: (state, action) => {\n      const wordId = action.payload;\n      const index = state.selectedWords.indexOf(wordId);\n      if (index > -1) {\n        state.selectedWords.splice(index, 1);\n      } else {\n        state.selectedWords.push(wordId);\n      }\n    },\n    selectWords: (state, action) => {\n      state.selectedWords = action.payload;\n    },\n    clearSelection: state => {\n      state.selectedWords = [];\n    },\n    markAsFiller: (state, action) => {\n      const word = state.words.find(w => w.text === action.payload);\n      if (word) {\n        word.isFiller = true;\n      }\n    },\n    clearError: state => {\n      state.error = null;\n    },\n    resetTranscript: state => {\n      state.words = [];\n      state.selectedWords = [];\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    // Transcribe audio\n    builder.addCase(transcribeAudio.pending, state => {\n      state.isTranscribing = true;\n      state.error = null;\n    }).addCase(transcribeAudio.fulfilled, (state, action) => {\n      var _action$payload;\n      state.isTranscribing = false;\n      if ((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.data) {\n        state.words = action.payload.data.transcript || [];\n      }\n    }).addCase(transcribeAudio.rejected, (state, action) => {\n      state.isTranscribing = false;\n      state.error = action.payload || 'Transcription failed';\n    });\n\n    // Remove fillers\n    builder.addCase(removeFillers.pending, state => {\n      state.isTranscribing = true;\n      state.error = null;\n    }).addCase(removeFillers.fulfilled, state => {\n      state.isTranscribing = false;\n      state.selectedWords = [];\n    }).addCase(removeFillers.rejected, (state, action) => {\n      state.isTranscribing = false;\n      state.error = action.payload || 'Filler removal failed';\n    });\n\n    // Remove auto detected fillers\n    builder.addCase(removeAutoDetectedFillers.pending, state => {\n      state.isTranscribing = true;\n      state.error = null;\n    }).addCase(removeAutoDetectedFillers.fulfilled, state => {\n      state.isTranscribing = false;\n    }).addCase(removeAutoDetectedFillers.rejected, (state, action) => {\n      state.isTranscribing = false;\n      state.error = action.payload || 'Auto filler removal failed';\n    });\n  }\n});\nexport const {\n  setWords,\n  toggleWordSelection,\n  selectWords,\n  clearSelection,\n  markAsFiller,\n  clearError,\n  resetTranscript\n} = transcriptSlice.actions;\nexport default transcriptSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","apiService","initialState","words","isTranscribing","error","selectedWords","transcribeAudio","projectId","rejectWithValue","formData","FormData","append","response","post","headers","data","_error$response","_error$response$data","removeFillers","_error$response2","_error$response2$data","removeAutoDetectedFillers","autoDetect","_error$response3","_error$response3$data","transcriptSlice","name","reducers","setWords","state","action","payload","toggleWordSelection","wordId","index","indexOf","splice","push","selectWords","clearSelection","markAsFiller","word","find","w","text","isFiller","clearError","resetTranscript","extraReducers","builder","addCase","pending","fulfilled","_action$payload","transcript","rejected","actions","reducer"],"sources":["/Users/miko/Documents/Project/real_projects/Snipix_web/src/redux/slices/transcriptSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { TranscriptState, TranscriptWord, TranscribeResponse, RemoveFillersResponse, ApiResponse } from '../../types';\nimport { apiService } from '../../services/apiService';\n\nconst initialState: TranscriptState = {\n  words: [],\n  isTranscribing: false,\n  error: null,\n  selectedWords: [],\n};\n\n// Async thunks\nexport const transcribeAudio = createAsyncThunk(\n  'transcript/transcribeAudio',\n  async (projectId: string, { rejectWithValue }) => {\n    try {\n      const formData = new FormData();\n      formData.append('project_id', projectId);\n      \n      const response = await apiService.post<ApiResponse<TranscribeResponse>>(`/media/transcribe`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      });\n      return response.data;\n    } catch (error: any) {\n      return rejectWithValue(error.response?.data?.error || 'Transcription failed');\n    }\n  }\n);\n\nexport const removeFillers = createAsyncThunk(\n  'transcript/removeFillers',\n  async ({ projectId, selectedWords }: { projectId: string; selectedWords: string[] }, { rejectWithValue }) => {\n    try {\n      const response = await apiService.post<ApiResponse<RemoveFillersResponse>>(`/media/remove-fillers`, {\n        projectId,\n        selectedWords,\n      });\n      return response.data;\n    } catch (error: any) {\n      return rejectWithValue(error.response?.data?.error || 'Filler removal failed');\n    }\n  }\n);\n\nexport const removeAutoDetectedFillers = createAsyncThunk(\n  'transcript/removeAutoDetectedFillers',\n  async (projectId: string, { rejectWithValue }) => {\n    try {\n      const response = await apiService.post<ApiResponse<RemoveFillersResponse>>(`/remove-fillers`, {\n        projectId,\n        autoDetect: true,\n      });\n      return response.data;\n    } catch (error: any) {\n      return rejectWithValue(error.response?.data?.error || 'Auto filler removal failed');\n    }\n  }\n);\n\nconst transcriptSlice = createSlice({\n  name: 'transcript',\n  initialState,\n  reducers: {\n    setWords: (state, action: PayloadAction<TranscriptWord[]>) => {\n      state.words = action.payload;\n    },\n    toggleWordSelection: (state, action: PayloadAction<string>) => {\n      const wordId = action.payload;\n      const index = state.selectedWords.indexOf(wordId);\n      if (index > -1) {\n        state.selectedWords.splice(index, 1);\n      } else {\n        state.selectedWords.push(wordId);\n      }\n    },\n    selectWords: (state, action: PayloadAction<string[]>) => {\n      state.selectedWords = action.payload;\n    },\n    clearSelection: (state) => {\n      state.selectedWords = [];\n    },\n    markAsFiller: (state, action: PayloadAction<string>) => {\n      const word = state.words.find((w: TranscriptWord) => w.text === action.payload);\n      if (word) {\n        word.isFiller = true;\n      }\n    },\n    clearError: (state) => {\n      state.error = null;\n    },\n    resetTranscript: (state) => {\n      state.words = [];\n      state.selectedWords = [];\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    // Transcribe audio\n    builder\n      .addCase(transcribeAudio.pending, (state) => {\n        state.isTranscribing = true;\n        state.error = null;\n      })\n      .addCase(transcribeAudio.fulfilled, (state, action) => {\n        state.isTranscribing = false;\n        if (action.payload?.data) {\n          state.words = action.payload.data.transcript || [];\n        }\n      })\n      .addCase(transcribeAudio.rejected, (state, action) => {\n        state.isTranscribing = false;\n        state.error = action.payload as string || 'Transcription failed';\n      });\n\n    // Remove fillers\n    builder\n      .addCase(removeFillers.pending, (state) => {\n        state.isTranscribing = true;\n        state.error = null;\n      })\n      .addCase(removeFillers.fulfilled, (state) => {\n        state.isTranscribing = false;\n        state.selectedWords = [];\n      })\n      .addCase(removeFillers.rejected, (state, action) => {\n        state.isTranscribing = false;\n        state.error = action.payload as string || 'Filler removal failed';\n      });\n\n    // Remove auto detected fillers\n    builder\n      .addCase(removeAutoDetectedFillers.pending, (state) => {\n        state.isTranscribing = true;\n        state.error = null;\n      })\n      .addCase(removeAutoDetectedFillers.fulfilled, (state) => {\n        state.isTranscribing = false;\n      })\n      .addCase(removeAutoDetectedFillers.rejected, (state, action) => {\n        state.isTranscribing = false;\n        state.error = action.payload as string || 'Auto filler removal failed';\n      });\n  },\n});\n\nexport const {\n  setWords,\n  toggleWordSelection,\n  selectWords,\n  clearSelection,\n  markAsFiller,\n  clearError,\n  resetTranscript,\n} = transcriptSlice.actions;\n\nexport default transcriptSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}