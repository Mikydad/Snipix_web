{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { apiService } from '../../services/apiService';\nconst initialState = {\n  layers: [],\n  playheadTime: 0,\n  zoom: 1,\n  duration: 0,\n  markers: [],\n  selectedClips: [],\n  isPlaying: false,\n  isSnapping: true,\n  undoStack: [],\n  redoStack: []\n};\n\n// Async thunks\nexport const saveTimeline = createAsyncThunk('timeline/saveTimeline', async ({\n  projectId,\n  timelineState\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await apiService.post('/timeline/save', {\n      projectId,\n      timelineState\n    });\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    return rejectWithValue(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Failed to save timeline');\n  }\n});\nexport const loadTimeline = createAsyncThunk('timeline/loadTimeline', async (projectId, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await apiService.get(`/timeline/${projectId}`);\n    return response.data;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    return rejectWithValue(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Failed to load timeline');\n  }\n});\nconst timelineSlice = createSlice({\n  name: 'timeline',\n  initialState,\n  reducers: {\n    // Playhead controls\n    setPlayheadTime: (state, action) => {\n      state.playheadTime = Math.max(0, Math.min(action.payload, state.duration));\n    },\n    setDuration: (state, action) => {\n      state.duration = action.payload;\n    },\n    setIsPlaying: (state, action) => {\n      state.isPlaying = action.payload;\n    },\n    // Zoom and view controls\n    setZoom: (state, action) => {\n      state.zoom = Math.max(0.1, Math.min(action.payload, 10));\n    },\n    setIsSnapping: (state, action) => {\n      state.isSnapping = action.payload;\n    },\n    // Layer management\n    addLayer: (state, action) => {\n      state.layers.push(action.payload);\n      state.layers.sort((a, b) => a.order - b.order);\n    },\n    removeLayer: (state, action) => {\n      state.layers = state.layers.filter(layer => layer.id !== action.payload);\n    },\n    updateLayer: (state, action) => {\n      const index = state.layers.findIndex(layer => layer.id === action.payload.id);\n      if (index !== -1) {\n        state.layers[index] = {\n          ...state.layers[index],\n          ...action.payload\n        };\n      }\n    },\n    reorderLayers: (state, action) => {\n      const {\n        fromIndex,\n        toIndex\n      } = action.payload;\n      const layer = state.layers.splice(fromIndex, 1)[0];\n      state.layers.splice(toIndex, 0, layer);\n      // Update order property\n      state.layers.forEach((layer, index) => {\n        layer.order = index;\n      });\n    },\n    // Clip management\n    addClip: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        layer.clips.push(action.payload.clip);\n      }\n    },\n    removeClip: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        layer.clips = layer.clips.filter(clip => clip.id !== action.payload.clipId);\n      }\n    },\n    updateClip: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          Object.assign(clip, action.payload.updates);\n        }\n      }\n    },\n    moveClip: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.startTime = action.payload.newStartTime;\n          clip.endTime = clip.startTime + clip.duration;\n        }\n      }\n    },\n    // Selection management\n    selectClip: (state, action) => {\n      state.selectedClips = [action.payload];\n    },\n    selectMultipleClips: (state, action) => {\n      state.selectedClips = action.payload;\n    },\n    clearSelection: state => {\n      state.selectedClips = [];\n    },\n    // Keyframe management\n    addKeyframe: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.keyframes.push(action.payload.keyframe);\n        }\n      }\n    },\n    removeKeyframe: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.keyframes = clip.keyframes.filter(k => k.id !== action.payload.keyframeId);\n        }\n      }\n    },\n    // Marker management\n    addMarker: (state, action) => {\n      state.markers.push(action.payload);\n    },\n    removeMarker: (state, action) => {\n      state.markers = state.markers.filter(marker => marker.id !== action.payload);\n    },\n    updateMarker: (state, action) => {\n      const marker = state.markers.find(m => m.id === action.payload.id);\n      if (marker) {\n        Object.assign(marker, action.payload);\n      }\n    },\n    // Undo/Redo\n    saveState: state => {\n      state.undoStack.push({\n        ...state\n      });\n      state.redoStack = [];\n    },\n    undo: state => {\n      if (state.undoStack.length > 0) {\n        const previousState = state.undoStack.pop();\n        state.redoStack.push({\n          ...state\n        });\n        Object.assign(state, previousState);\n      }\n    },\n    redo: state => {\n      if (state.redoStack.length > 0) {\n        const nextState = state.redoStack.pop();\n        state.undoStack.push({\n          ...state\n        });\n        Object.assign(state, nextState);\n      }\n    },\n    // Timeline operations\n    splitClip: (state, action) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip && action.payload.splitTime > clip.startTime && action.payload.splitTime < clip.endTime) {\n          const newClip = {\n            ...clip,\n            id: `${clip.id}_split_${Date.now()}`,\n            startTime: action.payload.splitTime,\n            duration: clip.endTime - action.payload.splitTime\n          };\n          clip.duration = action.payload.splitTime - clip.startTime;\n          clip.endTime = action.payload.splitTime;\n          layer.clips.push(newClip);\n        }\n      }\n    },\n    // Reset timeline\n    resetTimeline: state => {\n      Object.assign(state, initialState);\n    }\n  },\n  extraReducers: builder => {\n    // Save timeline\n    builder.addCase(saveTimeline.pending, state => {\n      // Could add loading state here\n    }).addCase(saveTimeline.fulfilled, state => {\n      // Success state\n    }).addCase(saveTimeline.rejected, (state, action) => {\n      // Error state\n      console.error('Failed to save timeline:', action.payload);\n    });\n\n    // Load timeline\n    builder.addCase(loadTimeline.pending, state => {\n      // Could add loading state here\n    }).addCase(loadTimeline.fulfilled, (state, action) => {\n      if (action.payload) {\n        Object.assign(state, action.payload);\n      }\n    }).addCase(loadTimeline.rejected, (state, action) => {\n      console.error('Failed to load timeline:', action.payload);\n    });\n  }\n});\nexport const {\n  setPlayheadTime,\n  setDuration,\n  setIsPlaying,\n  setZoom,\n  setIsSnapping,\n  addLayer,\n  removeLayer,\n  updateLayer,\n  reorderLayers,\n  addClip,\n  removeClip,\n  updateClip,\n  moveClip,\n  selectClip,\n  selectMultipleClips,\n  clearSelection,\n  addKeyframe,\n  removeKeyframe,\n  addMarker,\n  removeMarker,\n  updateMarker,\n  saveState,\n  undo,\n  redo,\n  splitClip,\n  resetTimeline\n} = timelineSlice.actions;\nexport default timelineSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","apiService","initialState","layers","playheadTime","zoom","duration","markers","selectedClips","isPlaying","isSnapping","undoStack","redoStack","saveTimeline","projectId","timelineState","rejectWithValue","response","post","data","error","_error$response","_error$response$data","loadTimeline","get","_error$response2","_error$response2$data","timelineSlice","name","reducers","setPlayheadTime","state","action","Math","max","min","payload","setDuration","setIsPlaying","setZoom","setIsSnapping","addLayer","push","sort","a","b","order","removeLayer","filter","layer","id","updateLayer","index","findIndex","reorderLayers","fromIndex","toIndex","splice","forEach","addClip","find","l","layerId","clips","clip","removeClip","clipId","updateClip","c","Object","assign","updates","moveClip","startTime","newStartTime","endTime","selectClip","selectMultipleClips","clearSelection","addKeyframe","keyframes","keyframe","removeKeyframe","k","keyframeId","addMarker","removeMarker","marker","updateMarker","m","saveState","undo","length","previousState","pop","redo","nextState","splitClip","splitTime","newClip","Date","now","resetTimeline","extraReducers","builder","addCase","pending","fulfilled","rejected","console","actions","reducer"],"sources":["/Users/miko/Documents/Project/real_projects/Snipix_web/src/redux/slices/timelineSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport { TimelineState, Layer, Clip, Keyframe, Marker, ApiResponse } from '../../types';\nimport { apiService } from '../../services/apiService';\n\nconst initialState: TimelineState = {\n  layers: [],\n  playheadTime: 0,\n  zoom: 1,\n  duration: 0,\n  markers: [],\n  selectedClips: [],\n  isPlaying: false,\n  isSnapping: true,\n  undoStack: [],\n  redoStack: [],\n};\n\n// Async thunks\nexport const saveTimeline = createAsyncThunk(\n  'timeline/saveTimeline',\n  async ({ projectId, timelineState }: { projectId: string; timelineState: TimelineState }, { rejectWithValue }) => {\n    try {\n      const response = await apiService.post<ApiResponse<any>>('/timeline/save', {\n        projectId,\n        timelineState,\n      });\n      return response.data;\n    } catch (error: any) {\n      return rejectWithValue(error.response?.data?.error || 'Failed to save timeline');\n    }\n  }\n);\n\nexport const loadTimeline = createAsyncThunk(\n  'timeline/loadTimeline',\n  async (projectId: string, { rejectWithValue }) => {\n    try {\n      const response = await apiService.get<ApiResponse<TimelineState>>(`/timeline/${projectId}`);\n      return response.data;\n    } catch (error: any) {\n      return rejectWithValue(error.response?.data?.error || 'Failed to load timeline');\n    }\n  }\n);\n\nconst timelineSlice = createSlice({\n  name: 'timeline',\n  initialState,\n  reducers: {\n    // Playhead controls\n    setPlayheadTime: (state, action: PayloadAction<number>) => {\n      state.playheadTime = Math.max(0, Math.min(action.payload, state.duration));\n    },\n    setDuration: (state, action: PayloadAction<number>) => {\n      state.duration = action.payload;\n    },\n    setIsPlaying: (state, action: PayloadAction<boolean>) => {\n      state.isPlaying = action.payload;\n    },\n\n    // Zoom and view controls\n    setZoom: (state, action: PayloadAction<number>) => {\n      state.zoom = Math.max(0.1, Math.min(action.payload, 10));\n    },\n    setIsSnapping: (state, action: PayloadAction<boolean>) => {\n      state.isSnapping = action.payload;\n    },\n\n    // Layer management\n    addLayer: (state, action: PayloadAction<Layer>) => {\n      state.layers.push(action.payload);\n      state.layers.sort((a, b) => a.order - b.order);\n    },\n    removeLayer: (state, action: PayloadAction<string>) => {\n      state.layers = state.layers.filter(layer => layer.id !== action.payload);\n    },\n    updateLayer: (state, action: PayloadAction<Partial<Layer> & { id: string }>) => {\n      const index = state.layers.findIndex(layer => layer.id === action.payload.id);\n      if (index !== -1) {\n        state.layers[index] = { ...state.layers[index], ...action.payload };\n      }\n    },\n    reorderLayers: (state, action: PayloadAction<{ fromIndex: number; toIndex: number }>) => {\n      const { fromIndex, toIndex } = action.payload;\n      const layer = state.layers.splice(fromIndex, 1)[0];\n      state.layers.splice(toIndex, 0, layer);\n      // Update order property\n      state.layers.forEach((layer, index) => {\n        layer.order = index;\n      });\n    },\n\n    // Clip management\n    addClip: (state, action: PayloadAction<{ layerId: string; clip: Clip }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        layer.clips.push(action.payload.clip);\n      }\n    },\n    removeClip: (state, action: PayloadAction<{ layerId: string; clipId: string }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        layer.clips = layer.clips.filter(clip => clip.id !== action.payload.clipId);\n      }\n    },\n    updateClip: (state, action: PayloadAction<{ layerId: string; clipId: string; updates: Partial<Clip> }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          Object.assign(clip, action.payload.updates);\n        }\n      }\n    },\n    moveClip: (state, action: PayloadAction<{ layerId: string; clipId: string; newStartTime: number }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.startTime = action.payload.newStartTime;\n          clip.endTime = clip.startTime + clip.duration;\n        }\n      }\n    },\n\n    // Selection management\n    selectClip: (state, action: PayloadAction<string>) => {\n      state.selectedClips = [action.payload];\n    },\n    selectMultipleClips: (state, action: PayloadAction<string[]>) => {\n      state.selectedClips = action.payload;\n    },\n    clearSelection: (state) => {\n      state.selectedClips = [];\n    },\n\n    // Keyframe management\n    addKeyframe: (state, action: PayloadAction<{ layerId: string; clipId: string; keyframe: Keyframe }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.keyframes.push(action.payload.keyframe);\n        }\n      }\n    },\n    removeKeyframe: (state, action: PayloadAction<{ layerId: string; clipId: string; keyframeId: string }>) => {\n      const layer = state.layers.find(l => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === action.payload.clipId);\n        if (clip) {\n          clip.keyframes = clip.keyframes.filter(k => k.id !== action.payload.keyframeId);\n        }\n      }\n    },\n\n    // Marker management\n    addMarker: (state, action: PayloadAction<Marker>) => {\n      state.markers.push(action.payload);\n    },\n    removeMarker: (state, action: PayloadAction<string>) => {\n      state.markers = state.markers.filter((marker: Marker) => marker.id !== action.payload);\n    },\n    updateMarker: (state, action: PayloadAction<Partial<Marker> & { id: string }>) => {\n      const marker = state.markers.find((m: Marker) => m.id === action.payload.id);\n      if (marker) {\n        Object.assign(marker, action.payload);\n      }\n    },\n\n    // Undo/Redo\n    saveState: (state) => {\n      state.undoStack.push({ ...state });\n      state.redoStack = [];\n    },\n    undo: (state) => {\n      if (state.undoStack.length > 0) {\n        const previousState = state.undoStack.pop()!;\n        state.redoStack.push({ ...state });\n        Object.assign(state, previousState);\n      }\n    },\n    redo: (state) => {\n      if (state.redoStack.length > 0) {\n        const nextState = state.redoStack.pop()!;\n        state.undoStack.push({ ...state });\n        Object.assign(state, nextState);\n      }\n    },\n\n    // Timeline operations\n    splitClip: (state, action: PayloadAction<{ layerId: string; clipId: string; splitTime: number }>) => {\n      const layer = state.layers.find((l: Layer) => l.id === action.payload.layerId);\n      if (layer) {\n        const clip = layer.clips.find((c: Clip) => c.id === action.payload.clipId);\n        if (clip && action.payload.splitTime > clip.startTime && action.payload.splitTime < clip.endTime) {\n          const newClip: Clip = {\n            ...clip,\n            id: `${clip.id}_split_${Date.now()}`,\n            startTime: action.payload.splitTime,\n            duration: clip.endTime - action.payload.splitTime,\n          };\n          clip.duration = action.payload.splitTime - clip.startTime;\n          clip.endTime = action.payload.splitTime;\n          layer.clips.push(newClip);\n        }\n      }\n    },\n\n    // Reset timeline\n    resetTimeline: (state) => {\n      Object.assign(state, initialState);\n    },\n  },\n  extraReducers: (builder) => {\n    // Save timeline\n    builder\n      .addCase(saveTimeline.pending, (state) => {\n        // Could add loading state here\n      })\n      .addCase(saveTimeline.fulfilled, (state) => {\n        // Success state\n      })\n      .addCase(saveTimeline.rejected, (state, action) => {\n        // Error state\n        console.error('Failed to save timeline:', action.payload);\n      });\n\n    // Load timeline\n    builder\n      .addCase(loadTimeline.pending, (state) => {\n        // Could add loading state here\n      })\n      .addCase(loadTimeline.fulfilled, (state, action) => {\n        if (action.payload) {\n          Object.assign(state, action.payload);\n        }\n      })\n      .addCase(loadTimeline.rejected, (state, action) => {\n        console.error('Failed to load timeline:', action.payload);\n      });\n  },\n});\n\nexport const {\n  setPlayheadTime,\n  setDuration,\n  setIsPlaying,\n  setZoom,\n  setIsSnapping,\n  addLayer,\n  removeLayer,\n  updateLayer,\n  reorderLayers,\n  addClip,\n  removeClip,\n  updateClip,\n  moveClip,\n  selectClip,\n  selectMultipleClips,\n  clearSelection,\n  addKeyframe,\n  removeKeyframe,\n  addMarker,\n  removeMarker,\n  updateMarker,\n  saveState,\n  undo,\n  redo,\n  splitClip,\n  resetTimeline,\n} = timelineSlice.actions;\n\nexport default timelineSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}