{"ast":null,"code":"var _jsxFileName = \"/Users/miko/Documents/Project/real_projects/Snipix_web/src/components/TimelineEditor.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport styled from 'styled-components';\nimport { useGesture } from 'react-use-gesture';\nimport { useAppSelector, useAppDispatch } from '../redux/store';\nimport { setPlayheadTime, setZoom, selectClip, clearSelection, moveClip, splitClip } from '../redux/slices/timelineSlice';\nimport TimelineRuler from './TimelineRuler';\nimport TimelineTrack from './TimelineTrack';\nimport Playhead from './Playhead';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst TimelineContainer = styled.div`\n  position: relative;\n  height: 100%;\n  background: ${({\n  theme\n}) => theme.colors.surface};\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n`;\n_c = TimelineContainer;\nconst TimelineHeader = styled.div`\n  height: 60px;\n  background: ${({\n  theme\n}) => theme.colors.surface};\n  border-bottom: 1px solid ${({\n  theme\n}) => theme.colors.border};\n  display: flex;\n  align-items: center;\n  padding-left: 120px; /* Account for layer headers width */\n`;\nconst TimelineBody = styled.div`\n  flex: 1;\n  display: flex;\n  overflow: hidden;\n`;\nconst LayerHeadersContainer = styled.div`\n  width: 120px;\n  background: ${({\n  theme\n}) => theme.colors.surfaceHover};\n  border-right: 1px solid ${({\n  theme\n}) => theme.colors.border};\n  flex-shrink: 0;\n`;\nconst TimelineContent = styled.div`\n  flex: 1;\n  position: relative;\n  transform: scaleX(${({\n  $zoom\n}) => $zoom});\n  transform-origin: left top;\n`;\n_c2 = TimelineContent;\nconst TracksContainer = styled.div`\n  position: relative;\n  height: calc(100% - 60px); // Account for ruler height\n  overflow-y: auto;\n  overflow-x: hidden;\n`;\n_c3 = TracksContainer;\nconst PlayheadContainer = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  z-index: 1000;\n  pointer-events: none;\n`;\n_c4 = PlayheadContainer;\nconst ZoomControls = styled.div`\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  display: flex;\n  gap: ${({\n  theme\n}) => theme.spacing.sm};\n  z-index: 100;\n`;\n_c5 = ZoomControls;\nconst ZoomButton = styled.button`\n  width: 32px;\n  height: 32px;\n  border: 1px solid ${({\n  theme\n}) => theme.colors.border};\n  background: ${({\n  theme\n}) => theme.colors.surface};\n  color: ${({\n  theme\n}) => theme.colors.text};\n  border-radius: ${({\n  theme\n}) => theme.borderRadius.sm};\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 14px;\n  \n  &:hover {\n    background: ${({\n  theme\n}) => theme.colors.surfaceHover};\n  }\n`;\n_c6 = ZoomButton;\nconst TimelineEditor = ({\n  projectId,\n  layers,\n  playheadTime,\n  zoom,\n  duration\n}) => {\n  _s();\n  const dispatch = useAppDispatch();\n  const timelineRef = useRef(null);\n  const {\n    selectedClips\n  } = useAppSelector(state => state.timeline);\n\n  // Convert time to pixels based on zoom\n  const timeToPixels = useCallback(time => {\n    const pixelsPerSecond = 100; // Base pixels per second\n    return time * pixelsPerSecond * zoom;\n  }, [zoom]);\n\n  // Convert pixels to time\n  const pixelsToTime = useCallback(pixels => {\n    const pixelsPerSecond = 100;\n    return pixels / (pixelsPerSecond * zoom);\n  }, [zoom]);\n\n  // Handle timeline scrolling\n  const handleTimelineScroll = useCallback(deltaX => {\n    const newTime = playheadTime - pixelsToTime(deltaX);\n    dispatch(setPlayheadTime(Math.max(0, Math.min(newTime, duration))));\n  }, [playheadTime, duration, pixelsToTime, dispatch]);\n\n  // Handle zoom\n  const handleZoom = useCallback(delta => {\n    const newZoom = Math.max(0.1, Math.min(10, zoom + delta * 0.1));\n    dispatch(setZoom(newZoom));\n  }, [zoom, dispatch]);\n\n  // Handle clip selection\n  const handleClipClick = useCallback((clipId, event) => {\n    if (event.ctrlKey || event.metaKey) {\n      // Multi-select\n      const newSelection = selectedClips.includes(clipId) ? selectedClips.filter(id => id !== clipId) : [...selectedClips, clipId];\n      // For now, just select single clip\n      dispatch(selectClip(clipId));\n    } else {\n      dispatch(selectClip(clipId));\n    }\n  }, [selectedClips, dispatch]);\n\n  // Handle playhead positioning\n  const handlePlayheadClick = useCallback(event => {\n    if (!timelineRef.current) return;\n    const rect = timelineRef.current.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const newTime = pixelsToTime(x);\n    dispatch(setPlayheadTime(Math.max(0, Math.min(newTime, duration))));\n    dispatch(clearSelection());\n  }, [pixelsToTime, duration, dispatch]);\n\n  // Handle clip splitting at playhead\n  const handleSplitAtPlayhead = useCallback(() => {\n    if (selectedClips.length === 1) {\n      const clipId = selectedClips[0];\n      const layer = layers.find(l => l.clips.some(c => c.id === clipId));\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === clipId);\n        if (clip && playheadTime > clip.startTime && playheadTime < clip.endTime) {\n          dispatch(splitClip({\n            layerId: layer.id,\n            clipId: clip.id,\n            splitTime: playheadTime\n          }));\n        }\n      }\n    }\n  }, [selectedClips, layers, playheadTime, dispatch]);\n\n  // Gesture handling for timeline scrolling\n  const bind = useGesture({\n    onDrag: ({\n      delta: [deltaX],\n      event\n    }) => {\n      if (event.target === timelineRef.current) {\n        handleTimelineScroll(deltaX);\n      }\n    },\n    onWheel: ({\n      delta: [deltaX, deltaY],\n      event\n    }) => {\n      if (event.ctrlKey || event.metaKey) {\n        // Zoom\n        event.preventDefault();\n        handleZoom(-deltaY);\n      } else {\n        // Scroll timeline\n        event.preventDefault();\n        handleTimelineScroll(deltaX);\n      }\n    }\n  });\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = event => {\n      switch (event.key) {\n        case ' ':\n          event.preventDefault();\n          // Toggle play/pause\n          break;\n        case 'ArrowLeft':\n          event.preventDefault();\n          dispatch(setPlayheadTime(Math.max(0, playheadTime - 1)));\n          break;\n        case 'ArrowRight':\n          event.preventDefault();\n          dispatch(setPlayheadTime(Math.min(duration, playheadTime + 1)));\n          break;\n        case 'Delete':\n          event.preventDefault();\n          // Delete selected clips\n          break;\n        case 'c':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Copy selected clips\n          }\n          break;\n        case 'v':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Paste clips\n          }\n          break;\n        case 'z':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            if (event.shiftKey) {\n              // Redo\n            } else {\n              // Undo\n            }\n          }\n          break;\n        case 's':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Save timeline\n          }\n          break;\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [playheadTime, duration, dispatch]);\n  return /*#__PURE__*/_jsxDEV(TimelineContainer, {\n    ref: timelineRef,\n    ...bind(),\n    children: [/*#__PURE__*/_jsxDEV(TimelineRuler, {\n      duration: duration,\n      zoom: zoom,\n      playheadTime: playheadTime,\n      onTimeClick: handlePlayheadClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 254,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(TimelineContent, {\n      $zoom: zoom,\n      children: /*#__PURE__*/_jsxDEV(TracksContainer, {\n        children: layers.map(layer => /*#__PURE__*/_jsxDEV(TimelineTrack, {\n          layer: layer,\n          zoom: zoom,\n          playheadTime: playheadTime,\n          selectedClips: selectedClips,\n          onClipClick: handleClipClick,\n          onClipMove: (clipId, newStartTime) => {\n            dispatch(moveClip({\n              layerId: layer.id,\n              clipId,\n              newStartTime\n            }));\n          }\n        }, layer.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 264,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 262,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(PlayheadContainer, {\n      children: /*#__PURE__*/_jsxDEV(Playhead, {\n        time: playheadTime,\n        left: timeToPixels(playheadTime),\n        onSplit: handleSplitAtPlayhead\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 284,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 283,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ZoomControls, {\n      children: [/*#__PURE__*/_jsxDEV(ZoomButton, {\n        onClick: () => handleZoom(-0.5),\n        children: \"-\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ZoomButton, {\n        onClick: () => handleZoom(0.5),\n        children: \"+\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 293,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 291,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 253,\n    columnNumber: 5\n  }, this);\n};\n_s(TimelineEditor, \"gf8xAEURalL0ur3YcCujUs5Cg/A=\", false, function () {\n  return [useAppDispatch, useAppSelector, useGesture];\n});\n_c7 = TimelineEditor;\nexport default TimelineEditor;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"TimelineContainer\");\n$RefreshReg$(_c2, \"TimelineContent\");\n$RefreshReg$(_c3, \"TracksContainer\");\n$RefreshReg$(_c4, \"PlayheadContainer\");\n$RefreshReg$(_c5, \"ZoomControls\");\n$RefreshReg$(_c6, \"ZoomButton\");\n$RefreshReg$(_c7, \"TimelineEditor\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","styled","useGesture","useAppSelector","useAppDispatch","setPlayheadTime","setZoom","selectClip","clearSelection","moveClip","splitClip","TimelineRuler","TimelineTrack","Playhead","jsxDEV","_jsxDEV","TimelineContainer","div","theme","colors","surface","_c","TimelineHeader","border","TimelineBody","LayerHeadersContainer","surfaceHover","TimelineContent","$zoom","_c2","TracksContainer","_c3","PlayheadContainer","_c4","ZoomControls","spacing","sm","_c5","ZoomButton","button","text","borderRadius","_c6","TimelineEditor","projectId","layers","playheadTime","zoom","duration","_s","dispatch","timelineRef","selectedClips","state","timeline","timeToPixels","time","pixelsPerSecond","pixelsToTime","pixels","handleTimelineScroll","deltaX","newTime","Math","max","min","handleZoom","delta","newZoom","handleClipClick","clipId","event","ctrlKey","metaKey","newSelection","includes","filter","id","handlePlayheadClick","current","rect","getBoundingClientRect","x","clientX","left","handleSplitAtPlayhead","length","layer","find","l","clips","some","c","clip","startTime","endTime","layerId","splitTime","bind","onDrag","target","onWheel","deltaY","preventDefault","handleKeyDown","key","shiftKey","window","addEventListener","removeEventListener","ref","children","onTimeClick","fileName","_jsxFileName","lineNumber","columnNumber","map","onClipClick","onClipMove","newStartTime","onSplit","onClick","_c7","$RefreshReg$"],"sources":["/Users/miko/Documents/Project/real_projects/Snipix_web/src/components/TimelineEditor.tsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback } from 'react';\nimport styled from 'styled-components';\nimport { useGesture } from 'react-use-gesture';\nimport { useAppSelector, useAppDispatch } from '../redux/store';\nimport { \n  setPlayheadTime, \n  setZoom, \n  selectClip,\n  clearSelection,\n  moveClip,\n  splitClip\n} from '../redux/slices/timelineSlice';\nimport { Layer, Clip } from '../types';\nimport TimelineRuler from './TimelineRuler';\nimport TimelineTrack from './TimelineTrack';\nimport Playhead from './Playhead';\n\nconst TimelineContainer = styled.div`\n  position: relative;\n  height: 100%;\n  background: ${({ theme }) => theme.colors.surface};\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst TimelineHeader = styled.div`\n  height: 60px;\n  background: ${({ theme }) => theme.colors.surface};\n  border-bottom: 1px solid ${({ theme }) => theme.colors.border};\n  display: flex;\n  align-items: center;\n  padding-left: 120px; /* Account for layer headers width */\n`;\n\nconst TimelineBody = styled.div`\n  flex: 1;\n  display: flex;\n  overflow: hidden;\n`;\n\nconst LayerHeadersContainer = styled.div`\n  width: 120px;\n  background: ${({ theme }) => theme.colors.surfaceHover};\n  border-right: 1px solid ${({ theme }) => theme.colors.border};\n  flex-shrink: 0;\n`;\n\nconst TimelineContent = styled.div<{ $zoom: number }>`\n  flex: 1;\n  position: relative;\n  transform: scaleX(${({ $zoom }) => $zoom});\n  transform-origin: left top;\n`;\n\nconst TracksContainer = styled.div`\n  position: relative;\n  height: calc(100% - 60px); // Account for ruler height\n  overflow-y: auto;\n  overflow-x: hidden;\n`;\n\nconst PlayheadContainer = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  z-index: 1000;\n  pointer-events: none;\n`;\n\nconst ZoomControls = styled.div`\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  display: flex;\n  gap: ${({ theme }) => theme.spacing.sm};\n  z-index: 100;\n`;\n\nconst ZoomButton = styled.button`\n  width: 32px;\n  height: 32px;\n  border: 1px solid ${({ theme }) => theme.colors.border};\n  background: ${({ theme }) => theme.colors.surface};\n  color: ${({ theme }) => theme.colors.text};\n  border-radius: ${({ theme }) => theme.borderRadius.sm};\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 14px;\n  \n  &:hover {\n    background: ${({ theme }) => theme.colors.surfaceHover};\n  }\n`;\n\nconst TimelineEditor: React.FC<{\n  projectId: string;\n  layers: Layer[];\n  playheadTime: number;\n  zoom: number;\n  duration: number;\n}> = ({ projectId, layers, playheadTime, zoom, duration }) => {\n  const dispatch = useAppDispatch();\n  const timelineRef = useRef<HTMLDivElement>(null);\n  const { selectedClips } = useAppSelector(state => state.timeline);\n\n  // Convert time to pixels based on zoom\n  const timeToPixels = useCallback((time: number) => {\n    const pixelsPerSecond = 100; // Base pixels per second\n    return time * pixelsPerSecond * zoom;\n  }, [zoom]);\n\n  // Convert pixels to time\n  const pixelsToTime = useCallback((pixels: number) => {\n    const pixelsPerSecond = 100;\n    return pixels / (pixelsPerSecond * zoom);\n  }, [zoom]);\n\n  // Handle timeline scrolling\n  const handleTimelineScroll = useCallback((deltaX: number) => {\n    const newTime = playheadTime - pixelsToTime(deltaX);\n    dispatch(setPlayheadTime(Math.max(0, Math.min(newTime, duration))));\n  }, [playheadTime, duration, pixelsToTime, dispatch]);\n\n  // Handle zoom\n  const handleZoom = useCallback((delta: number) => {\n    const newZoom = Math.max(0.1, Math.min(10, zoom + delta * 0.1));\n    dispatch(setZoom(newZoom));\n  }, [zoom, dispatch]);\n\n  // Handle clip selection\n  const handleClipClick = useCallback((clipId: string, event: React.MouseEvent) => {\n    if (event.ctrlKey || event.metaKey) {\n      // Multi-select\n      const newSelection = selectedClips.includes(clipId)\n        ? selectedClips.filter(id => id !== clipId)\n        : [...selectedClips, clipId];\n      // For now, just select single clip\n      dispatch(selectClip(clipId));\n    } else {\n      dispatch(selectClip(clipId));\n    }\n  }, [selectedClips, dispatch]);\n\n  // Handle playhead positioning\n  const handlePlayheadClick = useCallback((event: React.MouseEvent) => {\n    if (!timelineRef.current) return;\n    \n    const rect = timelineRef.current.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const newTime = pixelsToTime(x);\n    dispatch(setPlayheadTime(Math.max(0, Math.min(newTime, duration))));\n    dispatch(clearSelection());\n  }, [pixelsToTime, duration, dispatch]);\n\n  // Handle clip splitting at playhead\n  const handleSplitAtPlayhead = useCallback(() => {\n    if (selectedClips.length === 1) {\n      const clipId = selectedClips[0];\n      const layer = layers.find(l => l.clips.some(c => c.id === clipId));\n      if (layer) {\n        const clip = layer.clips.find(c => c.id === clipId);\n        if (clip && playheadTime > clip.startTime && playheadTime < clip.endTime) {\n          dispatch(splitClip({\n            layerId: layer.id,\n            clipId: clip.id,\n            splitTime: playheadTime\n          }));\n        }\n      }\n    }\n  }, [selectedClips, layers, playheadTime, dispatch]);\n\n  // Gesture handling for timeline scrolling\n  const bind = useGesture({\n    onDrag: ({ delta: [deltaX], event }) => {\n      if (event.target === timelineRef.current) {\n        handleTimelineScroll(deltaX);\n      }\n    },\n    onWheel: ({ delta: [deltaX, deltaY], event }) => {\n      if (event.ctrlKey || event.metaKey) {\n        // Zoom\n        event.preventDefault();\n        handleZoom(-deltaY);\n      } else {\n        // Scroll timeline\n        event.preventDefault();\n        handleTimelineScroll(deltaX);\n      }\n    }\n  });\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      switch (event.key) {\n        case ' ':\n          event.preventDefault();\n          // Toggle play/pause\n          break;\n        case 'ArrowLeft':\n          event.preventDefault();\n          dispatch(setPlayheadTime(Math.max(0, playheadTime - 1)));\n          break;\n        case 'ArrowRight':\n          event.preventDefault();\n          dispatch(setPlayheadTime(Math.min(duration, playheadTime + 1)));\n          break;\n        case 'Delete':\n          event.preventDefault();\n          // Delete selected clips\n          break;\n        case 'c':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Copy selected clips\n          }\n          break;\n        case 'v':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Paste clips\n          }\n          break;\n        case 'z':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            if (event.shiftKey) {\n              // Redo\n            } else {\n              // Undo\n            }\n          }\n          break;\n        case 's':\n          if (event.ctrlKey || event.metaKey) {\n            event.preventDefault();\n            // Save timeline\n          }\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [playheadTime, duration, dispatch]);\n\n  return (\n    <TimelineContainer ref={timelineRef} {...bind()}>\n      <TimelineRuler \n        duration={duration}\n        zoom={zoom}\n        playheadTime={playheadTime}\n        onTimeClick={handlePlayheadClick}\n      />\n      \n      <TimelineContent $zoom={zoom}>\n        <TracksContainer>\n          {layers.map((layer) => (\n            <TimelineTrack\n              key={layer.id}\n              layer={layer}\n              zoom={zoom}\n              playheadTime={playheadTime}\n              selectedClips={selectedClips}\n              onClipClick={handleClipClick}\n              onClipMove={(clipId, newStartTime) => {\n                dispatch(moveClip({\n                  layerId: layer.id,\n                  clipId,\n                  newStartTime\n                }));\n              }}\n            />\n          ))}\n        </TracksContainer>\n      </TimelineContent>\n\n      <PlayheadContainer>\n        <Playhead \n          time={playheadTime}\n          left={timeToPixels(playheadTime)}\n          onSplit={handleSplitAtPlayhead}\n        />\n      </PlayheadContainer>\n\n      <ZoomControls>\n        <ZoomButton onClick={() => handleZoom(-0.5)}>-</ZoomButton>\n        <ZoomButton onClick={() => handleZoom(0.5)}>+</ZoomButton>\n      </ZoomControls>\n    </TimelineContainer>\n  );\n};\n\nexport default TimelineEditor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}